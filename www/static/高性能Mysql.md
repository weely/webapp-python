## 高性能Mysql（第三版）笔记

### 一、Mysql架构及历史


### 二、Mysql的基准测试


### 三、服务器性能剖析
    主要解答问题： 经常碰到的3个性能相关的服务请求是：
        a. 如何确定服务器是否达到了性能最佳的状态
        b. 找出查询语句为什么不够快
        c. 诊断被用户描述成“停顿”,“堆积”或者“卡死”的某些间歇性疑难故障
    考虑解决方法：使用性能剖析profiling（专注于服务器时间花在那里）
    3.1 性能优化简介：
        性能：“每秒查询次数”，“cpu利用率”，“可拓展性”。。。？（这些都没问题，不同的人在不同场景下对性能有不同的理解）
        性能定义(正式的性能定义)：完成某件任务所需要的时间度量（即响应时间）
           通过任务与时间而资源来测量性能
        优化：假设性能优化就是在一定的工作负载下尽可能地降低响应时间
        优化的第二原则：需要先弄清时间花在哪里

        性能剖析是测量和分析时间花在哪里的主要方法
        性能剖析步骤：测量任务所花时间；对结果进行统计和排序，将重要的任务排在前面

        3.1.1 性能剖析工具的工作方式：在任务开始时启动计时器，在任务结束时停止计时器，然后用结束时间减去启动时间得到响应时间

        Percona Toolkit    pt-query-digest

        3.1.2 理解性能剖析
        值得优化的查询（worthwhile query）

        异常情况
            某些任务没出现性能剖析的前面也需要优化（任务执行次数少，但每次执行都非常慢）
        未知的未知

        被掩藏的细节
            性能剖析无法显示所有响应时间的分布
    3.2 对应用程序进行性能剖析
        影响性能的诸多因素：
        * 外部资源，比如调用了外部的web服务或者搜索引擎
        * 应用需要处理非常大的数据（分析一个超大的XML文件）
        * 在循环中执行昂贵的操作（滥用正则表达式）
        * 使用低效的算法（使用暴力搜索算法来查找列表中的项）
        New relic工具
    3.2.1 测量PHP应用程序
    （工具：xhprof(可拓展性好，可在生产环境大量部署并全天候使用，能针对函数调用进行分析，根据耗费的时间排序)， xdebug）
    Ifp:
        可剖析三种情况：应用程序的请求（如page view）,数据库的查询及缓存的查询
        可以将计数器和计时器输入到Apache，通过Apache可以将结果写入到日志中
        Ifp不会保存其他数据，所以不需要有管理员权限
        Ifp会自动对SQL添加注释
    使用Ifp: 只需要简单的在页面开始处调用start_request()
        eg: require_once('Instrumentation.php');
            Instrumentation::get_instance()->start_request();

    3.3 剖析Mysql查询
    3.3.1 剖析服务器负载
    第一种通过 --processlist 选项不断查看SHOW FULL PROCESSLIST 的输出，记录查询的第一次出现的时间与消失的时间
    第二种技术是通过抓取TCP网络包，后根据Mysql的客户端/服务器通信协议进行分析（可通过tcpdump将网络包数据保存到磁盘，后使用pt-query-digest的
    --type=tcpdump选项来解析并分析查询）
    第三种方法 通过Mysql Proxy代理层的脚本来记录所有查询（实践中很少用）

    分析查询日志
        使用慢查询日志

    3.3.2 剖析单条查询
        使用show profile





### 四、Schema与数据类型优化
    4.1 选择优化的数据类型

    4.2 Mysql schema设计中的陷阱

    4.3 范式与反范式
    范式的优点：
        范式的更新操作通常比反范式更快
        当数据较好的范式化时，就只有很少或者没有重复的数据，所以只需要更改更少的数据
        范式化的表通常更小，可以更好的放在内存中，所以执行操作会更快
        很少有多余的数据意味着检索列表数据时更少需要distanct或者group by语句
    范式化的缺点就是需要关联

    反范式的优缺点：
        反范式化的schema所有数据都在一张表中，可以很好的避免关联

    4.4 缓存表与汇总表

    4.5 加快alter table的速度

    4.6 总结
    * 尽量避免过度设计，例如会导致及其复杂查询的schema设计，或者有很多列的表的设计
    * 使用小而简单的合适的数据类型，除非真实数据模型中有需要，否则应尽可能避免使用NULL值
    * 尽量使用相同的数据类型存储相似或相关的值，尤其是在关联条件中使用的列
    * 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
    * 尽量使用整形定义标识列
    * 避免使用mysql已经遗弃的特性，例如指定浮点数的长度，或者整形的宽度
    * 小心使用ENUM(枚举型)和SET
    范式是好的，但有时反范式有时是需要的，并且能带来好处

#### 五、创建高性能索引
    索引是存储引擎用于快速找到记录的一条数据结构








































